#BFS与二叉搜索树

------

##Binary Tree BFS Traversal

二叉树层次遍历

```c++

//刚开始没看懂，自己画图细看几遍发生特别精妙，赞一个
//一定要记住队列是先进先出的

void levelTraversal(TreeNode *root)
{
    queue<TreeNode *> nodeQueue;
    TreeNode *currentNode;
    if (!root) {
        return;
    }

    //先塞入根节点
    nodeQueue.push(root);

    while (!nodeQueue.empty()) {

    	//当前节点值为queue中的第一个数据。
        currentNode = nodeQueue.front();

        //做进一步的处理，比如需要打印
        processNode(currentNode);
        if (currentNode->left) {
            nodeQueue.push(currentNode->left);
        }
        if (currentNode->right) {
            nodeQueue.push(currentNode->right);
        }

        //弹出当前的数据
        nodeQueue.pop();
    }
}

```

##Binary Tree to Linked Lists

Covert a binary tree to linked lists. Each linked list is correspondent to all the nodes at the same level.

核心问题：如何判断这一层已经遍历完毕？

解题思路：利用优先队列

代码示例：

```c++

//为什么你老是喜欢把你定义的result写成answer，我真的要报警了

ool isDummyNode(TreeNode *node) {
    return (node->left == node);
}

vector<list<TreeNode *>> linkedListsFromTree(TreeNode *root) {
    vector<list<TreeNode *>> result;
    list<TreeNode *> levelList;
    queue<TreeNode *> nodeQueue;
    TreeNode *currentNode;

    TreeNode dummyNode;
    dummyNode.left = &dummyNode;


    if (!root) {
        return result;
    }

    nodeQueue.push(&dummyNode);//dummyNode用于分割层
    nodeQueue.push(root);

    while (!nodeQueue.empty()) {
        currentNode = nodeQueue.front();
        if (isDummyNode(currentNode)) {
            if (!levelList.empty()) {

            	//若首节点时dummyNode且level不为空，就将该level塞入我们的最终结果列表
            	//然后清空level。代表了一层遍历的结束，开始遍历二叉树的下一层
                result.push_back(levelList);
                levelList.clear();
            }
            nodeQueue.pop();
            if (nodeQueue.empty()) {
                break;
            } else {
            	//每次遍历完一层，nodeQueue都会被塞入一个dummyNode
                nodeQueue.push(&dummyNode);
            }

        } else {
            levelList.push_back(currentNode);
            if (currentNode->left) {
                nodeQueue.push(currentNode->left);
            }
            if (currentNode->right) {
                nodeQueue.push(currentNode->right);
            }
            nodeQueue.pop();
        }
    }

    return result;
}

```


------