#二分搜索模板及其变体（上）

------

##前言

我们先来看下[二分搜索维基解释](https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)  
>* 在计算机科学中，折半搜索（英语：half-interval search），也称二分查找算法（binary search）、二分搜索法、二分搜索、二分探索，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。  

我个人比较喜欢读作“二分查找”。  
这里讲点二分查找的概念准备：  
二分查找主要解决“在一堆数中找出指定值的位置”这类问题。  
由此我们可以得出以下结论，要想应用二分查找，这一堆数必须满足以下特征：

- 存储在数组中
- 有序排列

所以如果是用链表存储的，将无法应用二分查找。（有的面试官会问：二分查找用什么数据结构？数组还是链表？）  
至于“有序排列”是递增还是递减，数组中是否存在相同元素，这些都不重要。不过一般情况，我们会希望数组是递增排列，且数组中的元素互不相同。


##如何做二分搜索

如果您认真看了前言中附的二分查找基本概念，基本思路应该有了，而且我相信很多报班的小伙伴之前已经听过甚至自己实现过。  
这里先讲个关于“二分查找”的有趣小故事  
> 二分查找可以解决（预排序数组的查找）问题：只要数组中包含T（即要查找的值），那么通过不断缩小包含T的范围，最终就可以找到它。一开始，范围覆盖整个数组。将数组的中间项与T进行比较，可以排除一半元素，范围缩小一半。就这样反复比较，反复缩小范围，最终就会在数组中找到T，或者确定原以为T所在的范围实际为空。对于包含N个元素的表，整个查找过程大约要经过log(2)N次比较。  

> 多数程序员都觉得只要理解了上面的描述，写出代码就不难了；但事实并非如此。如果你不认同这一点，最好的办法就是放下书本，自己动手写一写。试试吧。  

> 我在贝尔实验室和IBM的时候都出过这道考题。那些专业的程序员有几个小时的时间，可以用他们选择的语言把上面的描述写出来；写出高级伪代码也可以。考试结束后，差不多所有程序员都认为自己写出了正确的程序。于是，我们花了半个钟头来看他们编写的代码经过测试用例验证的结果。几次课，一百多人的结果相差无几：90%的程序员写的程序中有bug（我并不认为没有bug的代码就正确）。
  
> 我很惊讶：在足够的时间内，只有大约10%的专业程序员可以把这个小程序写对。但写不对这个小程序的还不止这些人：高德纳在《计算机程序设计的艺术 第3卷 排序和查找》第6.2.1节的“历史与参考文献”部分指出，虽然早在1946年就有人将二分查找的方法公诸于世，但直到1962年才有人写出没有bug的二分查找程序。

> ——乔恩·本特利，《编程珠玑（第1版）》第35-36页。

下面我们来动手写一下看看这传说中干掉90%程序员的二分查找到底如何

```C++

//[参考鸣谢](http://blog.csdn.net/v_july_v/article/details/7093204)
 
int binarySearch(int *array, int left, int right, int value)  
{
    while (left<=right)          //循环条件，适时而变  
    {  
        int middle = left + (right-left)/2;  //使用“(left + right) / 2”可能会造成栈溢出  
  
        if (array[middle]>value)  
        {  
            right =middle-1;   //right赋值，适时而变  
        }   
        else if(array[middle]<value)  
        {  
            left=middle+1;  
        }  
        else  
            return middle;    
        //可能会有读者认为刚开始时就要判断相等，但毕竟数组中不相等的情况更多  
        //如果每次循环都判断一下是否相等，将耗费时间  
    }

    return -1;  
}  

```

乍看之下也就区区十来行代码，但是其中有很多要容易犯错的细节，童鞋们需要特别注意注释中提到的要点以及middle值的设定。


##使用递归的二分搜索模板

简单粗暴，直接show code

```C++

int binarySearch(int *array, int left, int right, int value)
{
    if (left > right) return -1;
    
    int mid = left + (left + right)/2;
    if (arrary[mid] == value) {
        return mid;
    } else if (array[mid]> value) {
        return    binarySearch(array, left, mid -1, value);
    } else if (array[mid]< value) {
        return    binarySearch(array, mid+1, right, value);
    }
    
}

```

##A generic binary search template

汗，看到这个标题以为董老师要写C++模板，结果……  
还是我自己来吧  

```C++

//模板源码
template<typename T>
bool binarySearch(vector<T> &array,T value)
{
    int left = 0;
    int right = array.size() -1;
    while ( left <= right )
    {
        int middle = left + ( right - left ) /2;
        if ( array[middle] == value )
        {
            return true;
        }
        else if ( array[middle] > value )
        {
            right = middle - 1;
        }
        else if ( array[middle] < value )
        {
            left = middle + 1;
        }
    }
    return false;
}


//在vs下进行简单测试，通过
//你可以改变数组的大小或者value的大小来进行更多的测试
//如有更多问题请联系我email:alvinyeats@gmail.com

int _tmain(int argc, _TCHAR* argv[])
{	
	vector<int> array;
	for(int i =0; i<20;i++)
		array.push_back(i);

	int value = 21;

	bool status = binarySearch<int>(array, value);
	cout << status << endl;
	return 0;
}


```

##寻找插入位置




##Search in Rotated Sorted Array（在螺旋数组中查找）


##Find the Square Root（查找平方根）


##矩阵搜索


##范围搜索

------



------